import 'dart:async';

import 'package:analyzer/dart/element/element2.dart';
import 'package:analyzer/dart/element/type.dart';
import 'package:build/build.dart';
import 'package:code_builder/code_builder.dart';
import 'package:mirage/src/library_validator.dart';
import 'package:mirage/src/models/errors.dart';
import 'package:mirage/src/service_locator.dart';

class MirageBuilder implements Builder {
  @override
  FutureOr<void> build(BuildStep buildStep) async {
    final inputId = buildStep.inputId;
    final library = await _getInputLibrary(buildStep);
    if (library == null) {
      return;
    }
    late Set<DartType> typesToMock;
    try {
      typesToMock = LibraryValidator(library).validate();
    } on AnnotationNotFoundException catch (_) {
      return;
    }

    final notifierGenerator = ServiceLocator.getProviderGenerator(library);
    final mockLibrary = Library((builder) {
      builder.generatedByComment =
          "DO NOT MODIFY BY HAND! This file has been generated by "
          "mirage. If there is an issue with it please raise an issue at: "
          "https://github.com/Apadmi-Engineering/mirage/issues";
      builder.ignoreForFile.addAll(["invalid_use_of_internal_member", "unused_element"]);
      builder.body.add(const Code("\n"));
      for (final type in typesToMock) {
        builder.body.addAll(notifierGenerator.generate(type));
      }
    });

    await buildStep.writeAsString(
      inputId.changeExtension(".mirage.dart"),
      // ServiceLocator.formatter.format(
        "${mockLibrary.accept(ServiceLocator.emitter)}",
      // ),
    );
  }

  Future<LibraryElement2?> _getInputLibrary(BuildStep step) async {
    if (!await step.resolver.isLibrary(step.inputId)) {
      return null;
    }
    return step.inputLibrary;
  }

  @override
  Map<String, List<String>> get buildExtensions => {
        ".dart": [".mirage.dart", ".debug.mirage.dart"],
      };
}

Builder buildMirages(BuilderOptions options) => MirageBuilder();
